import{_ as l,c as i,o as t,a4 as s}from"./chunks/framework.DQ3SZeUm.js";const N=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"md/classical/cors/issue.md","filePath":"md/classical/cors/issue.md","lastUpdated":1725290669000}'),a={name:"md/classical/cors/issue.md"},o=s('<h2 id="解释正向代理和反向代理的概念-以及其在网络通信中的作用" tabindex="-1">解释正向代理和反向代理的概念，以及其在网络通信中的作用 <a class="header-anchor" href="#解释正向代理和反向代理的概念-以及其在网络通信中的作用" aria-label="Permalink to &quot;解释正向代理和反向代理的概念，以及其在网络通信中的作用&quot;">​</a></h2><p><strong>网络上有很多关于正向代理和反向代理的解释，要么关于概念化，要么很多时候我认为并没有把握正向代理和反向代理的核心。</strong></p><p><strong>正向代理</strong></p><p><strong>正向代理代表客户端向服务器发起请求，这意味着</strong></p><ul><li>客户端知道代理的存在：客户端配置了代理服务器的地址和端口，因此清楚所有的请求都通过这个代理来完成的（客户端需要这个代理）</li><li>服务器可能不知道真实的发起者：从服务器的角度看，它只看到有一个这样的请求。它无法直接知道请求的真实来源，到底是客户端自己还是 代理服务器发起的。</li><li>也就是正向代理是客户端的配置的，这种配置并不局限于在客户端直接配置，或者放到某一台服务器来完成</li></ul><p><strong>正向代理的实际用途</strong></p><ul><li>控制和过滤访问</li><li>提供匿名性</li><li>缓存常访问的资源</li></ul><p><strong>我们在Vite、Webpack中开启的本地服务器其实就是一种正向代理</strong></p><h2 id="反向代理" tabindex="-1">反向代理 <a class="header-anchor" href="#反向代理" aria-label="Permalink to &quot;反向代理&quot;">​</a></h2><p><strong>反向代理代表服务器接受来自客户端的请求，这意味着</strong></p><ul><li>服务器知道代理的存在：服务器配置了反向代理，所有的客户请求都首先被代理服务器接收和处理</li><li>客户端可能不知道代理的存在：对于客户端来说，它们直接与所认为的服务器通信，实际上他们是与代理服务器通信。客户端通常不知道其请 求实际上是被代理处理的</li></ul><p><strong>反向代理的实际用途</strong></p><ul><li>负载均衡：反向代理可以将接收到的请求分散到多个后端服务器上，从而优化资源的使用和提高响应速度</li><li>增强安全性：通过在服务器和互联网之间设置一个中间层，反向代理能够提供防火墙的功能和阻止不安全的网络请求</li><li>压缩和优化内容：反向代理还可以在将内容发送给用户前进行压缩，减少数据传输量，加快加载速度</li></ul><p><strong>我们在Nginx中配置的静态资源和API代理就是一种反向代理</strong></p><h2 id="描述如何使用nginx作为解决跨域的一种方法-并概述其工作原理" tabindex="-1">描述如何使用NGINX作为解决跨域的一种方法，并概述其工作原理 <a class="header-anchor" href="#描述如何使用nginx作为解决跨域的一种方法-并概述其工作原理" aria-label="Permalink to &quot;描述如何使用NGINX作为解决跨域的一种方法，并概述其工作原理&quot;">​</a></h2><p><strong>NGINX来解决跨域是我们在生产环境中常用的一种手段，在不同的需求下我们使用Nginx来解决跨域访问有两种方案</strong></p><p><strong>方案一：Nginx仅仅代理API服务器</strong></p><ul><li>在这种配置中，NGINX 承担了处理跨域问题的责任，通过在响应头中添加跨域资源共享（CORS）相关的HTTP头，使得前端应用能够从不同的源安 全地请求API</li><li>优势：将API请求集中处理，可以简化后端服务的CORS配置，特别是在后端服务分布在多个服务器或服务上时</li><li>工作原理：NGINX 作为接收来自前端的API请求，并将其转发到实际的后端服务。通过重写请求的URL并添加必要的HTTP头信息，NGINX 管理 跨源请求，从而允许前端代码与后端API进行交互</li></ul><p><strong>方案二：Nginx代理了静态资源和API服务器</strong></p><p><strong>当NGINX同时代理静态资源和API请求时，它可以为前端和后端提供一个统一的访问地址。</strong></p><ul><li>优势：这种配置简化了前端的配置，因为所有请求都发送到同一个服务器。此外，它还可以通过缓存机制提高静态资源的加载速度。</li><li>工作原理：静态资源和API请求都经过NGINX，然后根据请求的路径被适当地重写并转发到相应的后端服务</li><li>这种方式减少了跨域请求的复杂性，因为从客户端的角度看，所有请求都是同源的。</li></ul>',21),r=[o];function n(e,p,c,g,d,u){return t(),i("div",null,r)}const h=l(a,[["render",n]]);export{N as __pageData,h as default};
