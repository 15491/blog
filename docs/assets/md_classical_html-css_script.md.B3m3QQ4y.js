import{_ as s,c as i,o as a,a4 as t}from"./chunks/framework.DQ3SZeUm.js";const l="/blog/assets/script.BPZQc3MD.png",y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"md/classical/html-css/script.md","filePath":"md/classical/html-css/script.md","lastUpdated":1724686093000}'),e={name:"md/classical/html-css/script.md"},n=t(`<h2 id="defer和async属性在script标签上的作用" tabindex="-1">defer和async属性在script标签上的作用 <a class="header-anchor" href="#defer和async属性在script标签上的作用" aria-label="Permalink to &quot;defer和async属性在script标签上的作用&quot;">​</a></h2><p>浏览器在解析HTML的过程中，遇到了script元素是不能继续构建DOM树的</p><ul><li>他会停止继续构建，首先下载js代码，并执行(阻塞DOM Tree的构建)</li><li>只有等到js执行结束之后，才会继续解析HTML，构建DOM树</li></ul><p>为什么要这样处理</p><ul><li>因为js的作用之一就是操作DOM，修改DOM</li><li>如果等到DOM树构建完成并且渲染在执行js，会造成严重的回流和重绘，影响页面的性能</li><li>所以在遇到script元素的时候，会优先下载执行js，之后在构建DOM树</li></ul><p>但是这样也会带来新的问题</p><ul><li>在vue、react开发中，js代码会比HTML更重，下载的时间需要更长</li><li>造成页面的阻塞，在脚本下载，执行之后，浪费很多时间和性能</li></ul><p><strong>为了解决这个问题，script元素提供了连个属性 defer 和 async</strong></p><p>defer属性告诉浏览器不要等待脚本执行，而继续解析DOM Tree</p><ul><li>脚本会有浏览器来进行下载，但是不会阻塞DOM Tree的构建过程</li><li>如果脚本提前下载好了，他会等待DOM Tree构建完成，在DOMContentLoaded事件之前执行defer的代码</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./js/defer.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.addEventListener(&quot;DOMContentLoader&quot;, () =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;DOMContentLoader&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li>另外多个带defer的脚本是可以保持正确的顺序执行的</li><li>所以defer可以提高页面的性能，并且推荐放到head元素中</li></ul><p><strong>async特性与defer有些类似，他也能够让脚本不阻塞页面</strong></p><p><strong>async是一个让脚本的下载和执行是独立的</strong></p><ul><li>浏览器不会因为async脚本的下载而阻塞(与defer类似)</li><li>async脚本会在下载好之后立即执行，不能保证在DOMContentLoader之前或者之后执行(执行时会阻塞DOM Tree的构建)</li><li>async脚本不能保证顺序，他是独立下载，独立运行的，不会等待其他脚本</li></ul><p><img src="`+l+'" alt="script"></p><p><strong>使用场景</strong></p><ul><li>defer通常用于需要在文档解析后操作DOM的js代码，并且对于多个script文件有顺序要求</li><li>async通常用于独立的脚本，对于其他的脚本，甚至对于DOM没有以来的脚本</li></ul><p><strong>在现代的框架开发中，并不需要我们来配置async或defer</strong></p><ul><li>在使用脚手架或者自己搭建的webpack或者vite项目进行打包的时候，它会根据需要帮助我们加上defer属性</li><li>某些情况我们想要进行性能优化的时候，也可以手动机上async属性(例如一些第三方的分析工具或者广告追踪脚本)</li></ul>',20),p=[n];function r(h,c,d,k,o,E){return a(),i("div",null,p)}const u=s(e,[["render",r]]);export{y as __pageData,u as default};
