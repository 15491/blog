import{_ as t,c as a,o as i,a4 as l}from"./chunks/framework.DQ3SZeUm.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"md/classical/browser/issue.md","filePath":"md/classical/browser/issue.md","lastUpdated":1724773870000}'),s={name:"md/classical/browser/issue.md"},r=l('<h2 id="分析将javascript文件防止在html文档的不同位置-如头部和尾部-对加载和执行的影响" tabindex="-1">分析将JavaScript文件防止在HTML文档的不同位置（如头部和尾部） 对加载和执行的影响 <a class="header-anchor" href="#分析将javascript文件防止在html文档的不同位置-如头部和尾部-对加载和执行的影响" aria-label="Permalink to &quot;分析将JavaScript文件防止在HTML文档的不同位置（如头部和尾部） 对加载和执行的影响&quot;">​</a></h2><p><strong>这个主要考察JavaScript的下载和执行会阻塞DOM Tree的构建，另外你在回答的时候可以主动引出defer、async，显示你知识面的深度和广度</strong></p><p><strong>通常在开发中，JavaScript元素的编写位置我们会放在头部或者尾部，它们是会有区别的</strong></p><p><strong>情况一：普通JavaScript放在头部</strong></p><ul><li>当JavaScript文件放置在文档的头部时，浏览器在解析HTML到达</li><li>这意味着，直到JavaScript执行完成，页面的其余部分（如HTML和CSS）才会继续加载</li><li>这种做法通常会导致可见的延迟，尤其是当脚本文件较大或网络条件较差时</li><li>另外如果涉及到DOM元素操作，因为DOM还没有构建完成，所以操作DOM可能会失败，也需要慎重操作</li></ul><p><strong>情况二：普通JavaScript放到尾部</strong></p><ul><li>将JavaScript放在页面底部是一种常见的做法，以提高页面的加载速度。</li><li>这样，浏览器可以先加载页面的所有HTML和CSS内容，使用户尽快看到页面的结构和样式，而脚本将在页面的内容完全加载之后才开始下载和执行</li><li>这种方法通常可以提高首次渲染时间和用户感知的加载速度</li><li>当JavaScript放置在页面的底部时，它将在大部分或全部DOM元素已经加载后执行，从而减少了因DOM元素尚未加载而导致的错误</li></ul><p><strong>结合defer和async</strong></p><ul><li>defer属性让脚本的下载与DOM解析同步进行，但延迟到整个页面解析完成后再执行</li><li>async属性允许浏览器异步下载脚本，而不阻塞DOM的解析，脚本会在下载完后立即执行</li><li>选择使用哪一种取决于脚本的具体作用和需求</li></ul><h2 id="解释css文件是如何被浏览器解析并应用到网页上的" tabindex="-1">解释CSS文件是如何被浏览器解析并应用到网页上的 <a class="header-anchor" href="#解释css文件是如何被浏览器解析并应用到网页上的" aria-label="Permalink to &quot;解释CSS文件是如何被浏览器解析并应用到网页上的&quot;">​</a></h2><p><strong>下载CSS文件：当浏览器遇到一个 标签或 @import 指令引用的CSS文件时，它会首先下载这个文件</strong></p><p><strong>解析CSS：下载完成后，浏览器会解析CSS文件内容，将CSS代码转换成浏览器可以理解和使用的结构</strong></p><ul><li>这一结构通常称为CSS对象模型（CSSOM）</li></ul><p><strong>构建渲染树：当DOM和CSSOM都构建完毕后，浏览器将这两者结合起来形成渲染树</strong></p><ul><li>渲染树只包含实际要渲染的节点，并且每个节点都有相应的CSS样式信息</li></ul><p><strong>布局layout：一旦渲染树构建完成，浏览器会进行布局</strong></p><ul><li>在这个过程中，浏览器会计算每个节点的确切位置和大小。布局的结果依赖于渲染树中的节点以及它们的样式</li></ul><p><strong>绘制Paint：布局完成后，下一步是绘制，即浏览器将渲染树中的每个节点转换为屏幕上的实际像素</strong></p><ul><li>这包括绘制文本、颜色、图像、边框等视觉效果</li></ul><p><strong>合成Composite：某些元素可能需要在单独的层上进行绘制和合成</strong></p><ul><li>单独的合成层通常用于优化性能，特别是在动画和高频变化的元素上，因为它们可以在不影响页面其他部分的情况下独立更新</li></ul>',21),e=[r];function o(n,p,c,S,u,d){return i(),a("div",null,e)}const h=t(s,[["render",o]]);export{g as __pageData,h as default};
