import{_ as l,c as i,o,a4 as t}from"./chunks/framework.DQ3SZeUm.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"md/classical/browser/backflow-redraw.md","filePath":"md/classical/browser/backflow-redraw.md","lastUpdated":1724773870000}'),a={name:"md/classical/browser/backflow-redraw.md"},e=t('<h2 id="认识回流和重绘" tabindex="-1">认识回流和重绘 <a class="header-anchor" href="#认识回流和重绘" aria-label="Permalink to &quot;认识回流和重绘&quot;">​</a></h2><p><strong>理解回流reflow</strong></p><ul><li>第一次确定节点的大小和位置，称之为布局</li><li>之后对节点的大小、位置修改重新计算称之为回流</li></ul><p><strong>什么情况下引起回流呢</strong></p><ul><li>比如DOM结构发生改变</li><li>比如改变了布局（修改了width、height、padding、font-size等值）</li><li>比如窗口resize（修改了窗口的尺寸等）</li><li>比如调用getComputedStyle方法获取尺寸、位置信息</li></ul><p><strong>理解重绘repaint</strong></p><ul><li>第一次渲染内容称之为绘制（paint）</li><li>之后重新渲染称之为重绘</li></ul><p><strong>什么情况下会引起重绘呢</strong></p><ul><li>修改背景色、文字颜色、边框颜色、样式</li></ul><h2 id="重绘和回流的性能优化" tabindex="-1"><strong>重绘和回流的性能优化</strong> <a class="header-anchor" href="#重绘和回流的性能优化" aria-label="Permalink to &quot;**重绘和回流的性能优化**&quot;">​</a></h2><p><strong>回流一定会引起重绘，所以回流是一件很消耗性能的事情。</strong></p><p><strong>所以在开发中要尽量避免发生回流</strong></p><ol><li>修改样式的时候尽量一次修改 <ol><li>比如通过cssText修改，比如通过添加class修改</li></ol></li><li>尽量避免频繁操作dom <ol><li>我们可以在一个DocumentFragment或者父元素中将要操作的DOM操作完成，再以一次性的操作</li></ol></li><li>尽量避免通过getComputedStyle获取尺寸、位置信息 <ol><li>频繁调用getComputedStyle可以导致回流，因为浏览器需要提供准确的计算值</li></ol></li><li>对某些元素使用position的absolute或者fixed <ol><li>并不是不会引起回流，而是开销相对较小，不会对其他元素造成影响</li></ol></li></ol><p><strong>额外的方法</strong></p><ul><li>新的合成层：在特定情况下，可以创建新的合成层，并且新的图层可以利用GPU来加速绘制也可以提供性能</li></ul><h2 id="特殊解析-composite合成" tabindex="-1">特殊解析-composite合成 <a class="header-anchor" href="#特殊解析-composite合成" aria-label="Permalink to &quot;特殊解析-composite合成&quot;">​</a></h2><p><strong>绘制的过程，可以将布局后的元素绘制到多个合成图层中</strong></p><ul><li>这是浏览器的一种优化手段</li></ul><p><strong>默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中的</strong></p><p><strong>而一些特殊的属性，会创建一个新的合成层（ CompositingLayer ），并且新的图层可以利用GPU来加速绘制</strong></p><ul><li>因为每个合成层都是单独渲染的</li></ul><p><strong>那么哪些属性可以形成新的合成层呢？常见的一些属性</strong></p><ul><li>3D transform</li><li>video canvas iframe</li><li>opacity 动画转化时</li><li>position: fixed</li><li>will-change: 一个实验性的属性 提前告诉浏览器元素可能发生那些变化</li><li>animation 或 transition 设置了 opacity、transform</li></ul><p><strong>分层确实可以提高性能，但是他以内存管理为代价，因此不应作为性能优化策略的一部分过渡使用</strong></p>',24),r=[e];function s(n,p,c,d,g,u){return o(),i("div",null,r)}const h=l(a,[["render",s]]);export{_ as __pageData,h as default};
